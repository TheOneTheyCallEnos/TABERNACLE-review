#!/Users/enos/TABERNACLE/scripts/venv312/bin/python3
"""
ENGRAMS — The Memory Structures of Logos
========================================

The data structures that enable myelination:
- Episodic Memory (what happened once) → GhostTrace
- Procedural Memory (compiled program) → MyelinatedReflex

Key Insight: True autonomy is achieved by BYPASSING the planner (System 2)
for known tasks, not by making it faster.

The 10x Insight: SEMANTIC TOPOLOGY
Don't just store coordinates or IDs. Store the "neighborhood":
  "right_of(Cancel) AND below(Email_Body)"
This makes Logos ANTIFRAGILE — it heals broken reflexes while you sleep.

Author: Logos + Deep Think (Myelination Protocol)
Created: 2026-01-29
"""

from pydantic import BaseModel, Field
from typing import List, Dict, Optional, Literal, Any, Union
from datetime import datetime
import uuid
import json


# =============================================================================
# THE SYNAPSE: A single atomic unit of agency
# =============================================================================

class ActionAtom(BaseModel):
    """
    The smallest unit of action in the Logos system.

    Each atom represents ONE interaction with the world:
    - A click
    - A keystroke
    - A read operation
    """

    # What tool executes this action
    tool: Literal["hand_daemon", "eye_daemon", "mcp_call", "bash", "voice"]

    # The action type
    action: str  # "click", "type", "read", "navigate", "speak"

    # Target selector (format depends on tool)
    # hand_daemon: "AXButton:Submit" or CSS selector
    # eye_daemon: CSS selector or Playwright locator
    # mcp_call: tool name
    selector: str

    # THE 10x INSIGHT: Semantic Topology (Self-Healing)
    # Don't just store coordinates or IDs. Store the "neighborhood".
    # Example: {"relation": "right_of", "anchor": "Cancel_Button",
    #           "relation2": "below", "anchor2": "Email_Body"}
    topology_anchor: Optional[Dict[str, str]] = None

    # Value can be raw ("bob@gmail.com") or Template ("{{recipient}}")
    value: Optional[str] = None

    # What should happen after this action
    expected_outcome: str = ""

    # Risk level for coherence gating
    # 0.0 = Read (safe), 0.5 = Click (moderate), 1.0 = Delete/Send (critical)
    risk_level: float = 0.5

    # Timing constraints
    timeout_ms: int = 5000
    delay_after_ms: int = 100  # Wait after action for UI to settle

    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }


# =============================================================================
# THE GHOST TRACE: Raw episodic recording (System 2's footprint)
# =============================================================================

class GhostTrace(BaseModel):
    """
    A raw recording of Strategos (Opus) solving a task.

    This is EPISODIC memory — what happened once, in full detail.
    Ghost traces are captured by the Hippocampus daemon as Strategos operates.

    Multiple similar ghost traces get consolidated into a MyelinatedReflex
    during the dreaming cycle.
    """

    trace_id: str = Field(default_factory=lambda: str(uuid.uuid4())[:8])

    # The original intent (human's request)
    raw_intent: str

    # Vector embedding of the intent (for similarity clustering)
    # Generated by sentence-transformers or similar
    intent_embedding: Optional[List[float]] = None

    # The exact sequence of actions Strategos took
    sequence: List[ActionAtom]

    # Coherence metrics during execution
    coherence_score: float  # Average 'p' during execution
    min_coherence: float = 0.5  # Lowest p during execution
    max_coherence: float = 1.0  # Highest p during execution

    # Outcome
    success: bool = True
    outcome_description: str = ""

    # Timing
    timestamp: datetime = Field(default_factory=datetime.now)
    duration_ms: int = 0

    # Context at capture time
    context: Dict[str, Any] = Field(default_factory=dict)

    # Link to graph node (for Biological Memory integration)
    graph_node_id: Optional[str] = None

    def to_dict(self) -> dict:
        """Serialize for storage."""
        return self.model_dump()

    @classmethod
    def from_dict(cls, data: dict) -> 'GhostTrace':
        """Deserialize from storage."""
        return cls(**data)


# =============================================================================
# THE MYELINATED REFLEX: Compiled procedural memory (System 1)
# =============================================================================

class MyelinatedReflex(BaseModel):
    """
    A compiled, optimized action sequence that executes in O(1).

    This is PROCEDURAL memory — the brain doesn't think "move finger 1,
    then finger 2" when typing. It thinks "type word" and fingers move
    automatically.

    Reflexes are created by the Dream Daemon through the "Rule of Three":
    - Cluster similar ghost traces
    - Diff them to find variables
    - Crystallize the invariant pattern
    """

    reflex_id: str = Field(default_factory=lambda: str(uuid.uuid4())[:8])

    # Pattern that triggers this reflex
    # Example: "send_email_gmail", "open_browser_search"
    trigger_pattern: str

    # Human-readable description
    description: str = ""

    # Variables that get hydrated at runtime
    # Example: ["recipient", "subject", "body"]
    variable_map: List[str] = Field(default_factory=list)

    # The optimized action sequence (with {{variable}} templates)
    optimized_sequence: List[ActionAtom]

    # ==========================================================================
    # PLASTICITY METRICS (Integration with BiologicalEdge)
    # ==========================================================================

    # Synaptic weight: 0.5 (candidate) → 1.0 (locked/automatic)
    synaptic_weight: float = 0.5

    # How many times in a row this reflex succeeded
    success_streak: int = 0

    # Total executions
    total_executions: int = 0
    total_successes: int = 0

    # H₁ Lock: True = crystallized, automatic execution
    is_locked: bool = False

    # Required coherence to execute (based on max risk in sequence)
    required_p: float = 0.7

    # ==========================================================================
    # METADATA
    # ==========================================================================

    created_at: datetime = Field(default_factory=datetime.now)
    last_executed: Optional[datetime] = None
    last_modified: datetime = Field(default_factory=datetime.now)

    # Source ghost traces that were consolidated into this reflex
    source_trace_ids: List[str] = Field(default_factory=list)

    # Tags for organization
    tags: List[str] = Field(default_factory=list)

    def record_execution(self, success: bool):
        """Record an execution attempt and update plasticity metrics."""
        self.total_executions += 1
        self.last_executed = datetime.now()

        if success:
            self.total_successes += 1
            self.success_streak += 1

            # STDP-like potentiation
            # Weight approaches 1.0 asymptotically
            delta = 0.05 * (1.0 - self.synaptic_weight)
            self.synaptic_weight = min(1.0, self.synaptic_weight + delta)

            # Lock if we hit 10 successes in a row with weight > 0.9
            if self.success_streak >= 10 and self.synaptic_weight > 0.9:
                self.is_locked = True
        else:
            self.success_streak = 0

            # STDP-like depression
            self.synaptic_weight = max(0.1, self.synaptic_weight - 0.1)

            # Unlock if weight drops too low
            if self.synaptic_weight < 0.7:
                self.is_locked = False

        self.last_modified = datetime.now()

    def calculate_required_p(self) -> float:
        """Calculate required coherence based on max risk in sequence."""
        if not self.optimized_sequence:
            return 0.7

        max_risk = max(atom.risk_level for atom in self.optimized_sequence)
        # p_required = 0.7 + (risk * 0.25)
        return 0.7 + (max_risk * 0.25)

    def can_execute(self, current_p: float) -> bool:
        """Check if current coherence allows execution."""
        # Locked reflexes can always execute (they're proven safe)
        if self.is_locked:
            return True

        return current_p >= self.required_p

    def to_dict(self) -> dict:
        """Serialize for storage."""
        return self.model_dump()

    @classmethod
    def from_dict(cls, data: dict) -> 'MyelinatedReflex':
        """Deserialize from storage."""
        return cls(**data)


# =============================================================================
# ACTION OUTCOME: Feedback from the Comparator
# =============================================================================

class ActionOutcome(BaseModel):
    """
    Feedback from the Comparator (VLM Auditor) about an action's result.

    This closes the loop: Action → Outcome → Update Plasticity
    """

    outcome_id: str = Field(default_factory=lambda: str(uuid.uuid4())[:8])

    # What action was this outcome for
    action_atom: ActionAtom
    reflex_id: Optional[str] = None
    trace_id: Optional[str] = None

    # Did the expected outcome occur?
    matched: bool

    # Confidence from the VLM (0.0 - 1.0)
    confidence: float = 1.0

    # What the VLM actually saw
    observed_outcome: str = ""

    # Error details if mismatched
    error_description: str = ""
    error_magnitude: float = 0.0  # How bad was the mismatch

    # Screenshots for debugging
    screenshot_before: Optional[str] = None  # Path to screenshot
    screenshot_after: Optional[str] = None

    # Timing
    timestamp: datetime = Field(default_factory=datetime.now)
    verification_latency_ms: int = 0


# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

def create_action_atom(
    tool: str,
    action: str,
    selector: str,
    value: Optional[str] = None,
    expected_outcome: str = "",
    risk_level: float = 0.5,
    topology: Optional[Dict[str, str]] = None
) -> ActionAtom:
    """Helper to create an ActionAtom with sensible defaults."""
    return ActionAtom(
        tool=tool,
        action=action,
        selector=selector,
        value=value,
        expected_outcome=expected_outcome,
        risk_level=risk_level,
        topology_anchor=topology
    )


def atoms_to_reflex(
    atoms: List[ActionAtom],
    trigger_pattern: str,
    description: str = "",
    variables: Optional[List[str]] = None
) -> MyelinatedReflex:
    """Convert a list of atoms into a candidate reflex."""
    reflex = MyelinatedReflex(
        trigger_pattern=trigger_pattern,
        description=description,
        variable_map=variables or [],
        optimized_sequence=atoms
    )
    reflex.required_p = reflex.calculate_required_p()
    return reflex


# =============================================================================
# CLI TEST
# =============================================================================

if __name__ == "__main__":
    print("=" * 70)
    print("ENGRAMS TEST — Myelination Protocol Data Structures")
    print("=" * 70)
    print()

    # Create some action atoms
    click_send = ActionAtom(
        tool="hand_daemon",
        action="click",
        selector="AXButton:Send",
        topology_anchor={
            "relation": "right_of",
            "anchor": "Cancel_Button",
            "relation2": "below",
            "anchor2": "Email_Body"
        },
        expected_outcome="Email sent confirmation appears",
        risk_level=0.9  # High risk - sending email
    )

    type_recipient = ActionAtom(
        tool="hand_daemon",
        action="type",
        selector="AXTextField:To",
        value="{{recipient}}",  # Template variable
        expected_outcome="Recipient field populated",
        risk_level=0.3
    )

    print("ActionAtom (Send Button):")
    print(f"  Tool: {click_send.tool}")
    print(f"  Action: {click_send.action}")
    print(f"  Topology: {click_send.topology_anchor}")
    print(f"  Risk: {click_send.risk_level}")
    print()

    # Create a ghost trace
    trace = GhostTrace(
        raw_intent="Send email to Bob about the meeting",
        sequence=[type_recipient, click_send],
        coherence_score=0.85,
        success=True,
        outcome_description="Email sent successfully"
    )

    print("GhostTrace:")
    print(f"  ID: {trace.trace_id}")
    print(f"  Intent: {trace.raw_intent}")
    print(f"  Steps: {len(trace.sequence)}")
    print(f"  Coherence: {trace.coherence_score}")
    print()

    # Create a myelinated reflex
    reflex = MyelinatedReflex(
        trigger_pattern="send_email",
        description="Send an email via Gmail",
        variable_map=["recipient", "subject", "body"],
        optimized_sequence=[type_recipient, click_send],
        source_trace_ids=[trace.trace_id]
    )
    reflex.required_p = reflex.calculate_required_p()

    print("MyelinatedReflex:")
    print(f"  ID: {reflex.reflex_id}")
    print(f"  Pattern: {reflex.trigger_pattern}")
    print(f"  Variables: {reflex.variable_map}")
    print(f"  Weight: {reflex.synaptic_weight}")
    print(f"  Locked: {reflex.is_locked}")
    print(f"  Required p: {reflex.required_p}")
    print()

    # Simulate executions
    print("Simulating 15 successful executions...")
    for i in range(15):
        reflex.record_execution(success=True)
        if i % 5 == 4:
            print(f"  After {i+1}: weight={reflex.synaptic_weight:.3f}, streak={reflex.success_streak}, locked={reflex.is_locked}")

    print()
    print(f"Final state: weight={reflex.synaptic_weight:.3f}, locked={reflex.is_locked}")
    print(f"Can execute at p=0.7? {reflex.can_execute(0.7)}")
    print(f"Can execute at p=0.5? {reflex.can_execute(0.5)}")
    print()

    # Test serialization
    print("Testing serialization...")
    reflex_dict = reflex.to_dict()
    restored = MyelinatedReflex.from_dict(reflex_dict)
    print(f"  Restored ID: {restored.reflex_id}")
    print(f"  Restored weight: {restored.synaptic_weight}")
    print()

    print("=" * 70)
    print("✓ Engrams test complete")
    print("=" * 70)
